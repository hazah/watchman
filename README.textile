h2. Watchman

Rack based authorization middleware.

h2. Setup

h3. Rack

p. Watchman _must_ be downstream of some kind of authentication middleware. It _must_ have
a failure application declared, and you should declare which strategy to use by
default.

bc.. Rack::Builder.new do
  use Rack::Session::Cookie, :secret => "replace this with some secret key"

  ## Setup authentication

  use Warden::Manager do |warden|
    warden.default_strategies :password
    warden.failure_app = BadAuthenticationEndsUpHere
  end

  use Watchman::Manager do |watchman|
    # use the 'warden' strategy to get access to the permission collection
    warden.default_strategies :warden
    warden.failure_app = BadAuthorizationEndsUpHere
  end

  run SomeApp
end


h3. Session

p. One of the results of using any kind of permission objects is that you need to
tell Watchman how to serialize the permissions in and out of the session. You'll
need to set this up

bc.. Watchman::Manager.serialize_into_session do |permissions|
  permissions.map(&:id)
end

Watchman::Manager.serialize_from_session do |ids|
  Permission.get(ids)
end

p. This can of course be as complex as needed.


h3. Declare Some Strategies

p. You'll need to declare some strategies to be able to get Watchman to actually authorize.
Watchman uses the concept of strategies to determine if a request should be authorized.
Watchman will try strategies one after another until either,
* One succeeds
* No strategies found relevant
* A strategy fails

p. Conceptually a strategy is where you put the logic for determining the permissions
for a request. Practically, it's a decendant of @Watchman::Strategies::Base@.

p. You can define many strategies and one will be selected and used.

bc.. Watchman::Strategies.add(:warden) do
  def valid?
    !!env['warden'].nil?
  end

  def authorize!
    u = env['warden'].user(scope)
    u.nil? fail!("Could not authorize") : success!(u.permissions)
  end
end
