h2. Watchman

Rack based authorization middleware.

h2. Setup

h3. Rack

p. Watchman _must_ be downstream of some kind of authentication middleware. It _must_ have
a failure application declared, and you should declare which strategy to use by
default.

bc.. Rack::Builder.new do
  use Rack::Session::Cookie, :secret => "replace this with some secret key"

  ## Setup authentication

  use Warden::Manager do |warden|
    warden.default_strategies :password
    warden.failure_app = BadAuthenticationEndsUpHere
  end

  use Watchman::Manager do |watchman|
    # use the 'warden' strategy to get access to the permission collection
    warden.default_strategies :warden
    warden.failure_app = BadAuthorizationEndsUpHere
  end

  run SomeApp
end


h3. Session

p. One of the results of using any kind of permission objects is that you need to
tell Watchman how to serialize the permissions in and out of the session. You'll
need to set this up

bc.. Watchman::Manager.serialize_into_session do |permissions|
  permissions.map(&:id)
end

Watchman::Manager.serialize_from_session do |ids|
  Permission.get(ids)
end

p. This can of course be as complex as needed.


h3. Declare Some Strategies

p. You'll need to declare some strategies to be able to get Watchman to actually authorize.
Watchman uses the concept of strategies to determine if a request should be authorized.
Watchman will try strategies one after another until either,
* One succeeds
* No strategies found relevant
* A strategy fails

p. Conceptually a strategy is where you put the logic for determining the permissions
for a request. Practically, it's a decendant of @Watchman::Strategies::Base@.

p. You can define many strategies and one will be selected and used.

bc.. Watchman::Strategies.add(:warden) do
  def valid?
    env.has_key?('warden')
  end

  def authorize!
    u = env['warden'].user(scope)
    u.nil? fail!("Could not authorize") : success!(u.permissions)
  end
end

h3. Setup Permissions

p. We can process the current user scope and determine if the user has permission for a requested action.

p. We can define how to process collections of objects that the user has certain permissions for. By
supplying a collection block, we give Watchman a chance to preprocess an object collection and return
a collection authorized for the requested permission.

p. Supplying a resource block will enable us to check authorization of individual objects and collections for requested permissions.

bc.. Watchman::Permissions.add(:read_posts, scope: :anonymous) do
  # This block is called for collections that are not arrays, such as ActiveRecord::Relation objects.
  # Otherwise, the select method is called on the array passing it the resource
  # block
  collection do |posts|
    posts.where(published: true)
  end

  # Called to verify the permission and filtering collections of resources
  resource do |post|
    post.published?
  end
end

h3. Use it in your application

bc.. Warden::Manager.after_set_user do |user, auth, opts|
  env['watchman'].authorize! opts # use all default strategy
  env['watchman'].authorize! :warden, opts # use only the :warden strategy
end

posts = env['watchman'].permitted(:read_posts, Post.all) # Only retrieves posts where published is set to true
env['watchman'].permit! :read_posts # Throws :watchman if this permission does not currently active.
env['watchman'].permit! :read_posts, posts # Checks all posts to ensure each returns true for published?, throws :watchman if fails.

env['watchman'].permitted? :read_posts # Returns true if this permission is currently active.
env['watchman'].permitted? :read_posts, posts # Checks all posts to and returns true if each returns true for published?

p. This setup means that whenever a user is authenticated using warden, they will automatically
be authorized (their permissions will be known). Using the @permitted@ method you can retrieve
a collection of objects for which the user has the permission. Using the @permit!@ method you
can then test individual objects or entire collections whether the action is authorized or not.
and fail authorization for specific sets of arguments.
