h2. Watchman

Rack based authorization middleware.

h2. Setup

h3. Rack

p. Watchman _must_ be downstream of some kind of authentication middleware. It _must_ have
a failure application declared, and you should declare which strategy to use by
default.

bc.. Rack::Builder.new do
  use Rack::Session::Cookie, :secret => "replace this with some secret key"

  ## Setup authentication

  use Warden::Manager do |warden|
    warden.default_strategies :password
    warden.failure_app = BadAuthenticationEndsUpHere
  end

  use Watchman::Manager do |watchman|
    # use the 'warden' strategy to get access to the permission collection
    warden.default_strategies :warden
    warden.failure_app = BadAuthorizationEndsUpHere
  end

  run SomeApp
end


h3. Session

p. One of the results of using any kind of permission objects is that you need to
tell Watchman how to serialize the permissions in and out of the session. You'll
need to set this up

bc.. Watchman::Manager.serialize_into_session do |permissions|
  permissions.map(&:id)
end

Watchman::Manager.serialize_from_session do |ids|
  Permission.get(ids)
end

p. This can of course be as complex as needed.


h3. Declare Some Strategies

p. You'll need to declare some strategies to be able to get Watchman to actually authorize.
Watchman uses the concept of strategies to determine if a request should be authorized.
Watchman will try strategies one after another until either,
* One succeeds
* No strategies found relevant
* A strategy fails

p. Conceptually a strategy is where you put the logic for determining the permissions
for a request. Practically, it's a decendant of @Watchman::Strategies::Base@.

p. You can define many strategies and one will be selected and used.

bc.. Watchman::Strategies.add(:warden) do
  def valid?
    env.has_key?('warden')
  end

  def user
    env['warden'].user(scope)
  end

  def authorize!
    u = user
    u.nil? fail!("Could not authorize") : success!(u.permissions)
  end
end

h3. Setup Permissions

p. We can process the current user scope and determine if the user has permission for a requested action.

p. We can define how to process collections of objects that the user has certain permissions for. By
supplying a collection block, we give Watchman a chance to preprocess an object collection and return
a collection authorized for the requested permission.

p. Supplying a resource block will enable us to check authorization of individual objects and collections for requested permissions.

bc.. Watchman::Permissions.add(:read, :posts, scope: :anonymous) do
  scope do |user|
    !user.blocked?
  end

  collection do |posts|
    posts.where(published: true)
  end

  resource do |post|
    post.published?
  end
end

h3. Use it in your application

bc.. Warden::Manager.after_set_user do |user, auth, opts|
  env['watchman'].authorize! opts # use all default strategy
  env['watchman'].authorize! :warden, opts # use only the :warden strategy
end

posts = env['watchman'].permitted(:read, Post.all) # Checks that the user.blocked? returns false and then only retrieves posts where published is set to true
env['watchman'].permit! :read, posts # Checks that user.blocked? return false and then all posts to ensure each returns true for published?

p. This setup means that whenever a user is authenticated using warden, they will automatically
be authorized (their permissions will be known). Using the @permit!@ method you can then test
and fail authorization for specific sets of arguments.
